let _where = { lambda ; a:bool[1000000,1] b:f32[1000000,1] c:f32[]. let
    d:f32[] = convert_element_type[new_dtype=float32 weak_type=False] c
    e:f32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] d
    f:f32[1000000,1] = broadcast_in_dim[
      broadcast_dimensions=(np.int64(1),)
      shape=(1000000, 1)
      sharding=None
    ] e
    g:f32[1000000,1] = select_n a f b
  in (g,) } in
{ lambda h:f32[] i:u32[1000,2]; . let
    j:i32[1000000] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1000000,)
      sharding=None
    ] 0
    k:f32[1000000] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1000000,)
      sharding=None
    ] 1.0
    l:f32[1000000] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1000000,)
      sharding=None
    ] h
    m:f32[1000000] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1000000,)
      sharding=None
    ] -inf
    n:i32[1000000] o:f32[1000000] p:f32[1000000] q:f32[1000000] = scan[
      _split_transpose=False
      jaxpr={ lambda ; r:i32[1000000] s:f32[1000000] t:f32[1000000] u:f32[1000000]
          v:u32[2]. let
          w:i32[1000000] x:f32[1000000] y:f32[1000000] = pjit[
            name=one_step
            jaxpr={ lambda ; z:i32[1000000] ba:f32[1000000] bb:f32[1000000] bc:f32[1000000]
                bd:u32[2]. let
                be:key<fry>[] = random_wrap[impl=fry] bd
                bf:key<fry>[2] = random_split[shape=(2,)] be
                bg:u32[2,2] = random_unwrap bf
                bh:u32[1,2] = slice[
                  limit_indices=(1, 2)
                  start_indices=(0, 0)
                  strides=(1, 1)
                ] bg
                _:u32[2] = squeeze[dimensions=(0,)] bh
                bi:u32[1,2] = slice[
                  limit_indices=(2, 2)
                  start_indices=(1, 0)
                  strides=(1, 1)
                ] bg
                bj:u32[2] = squeeze[dimensions=(0,)] bi
                bk:key<fry>[] = random_wrap[impl=fry] bj
                bl:key<fry>[1000000] = random_split[shape=(1000000,)] bk
                bm:u32[1000000,2] = random_unwrap bl
                bn:f32[1000000] bo:f32[1000000] = pjit[
                  name=_rw_kernel
                  jaxpr={ lambda bp:f32[1] bq:f32[1]; br:u32[1000000,2] bs:f32[1000000]
                      bt:f32[1000000] bu:f32[1000000]. let
                      bv:f32[1000000,1] = reshape[
                        dimensions=None
                        new_sizes=(1000000, 1)
                        sharding=None
                      ] bt
                      bw:bool[1000000,1] = eq bv bv
                      bx:bool[1000000,1] = ne bv inf
                      by:bool[1000000,1] = and bw bx
                      bz:bool[1000000,1] = ne bv -inf
                      _:bool[1000000,1] = and by bz
                      ca:key<fry>[1000000] = random_wrap[impl=fry] br
                      cb:key<fry>[1000000,2] = random_split[shape=(2,)] ca
                      cc:u32[1000000,2,2] = random_unwrap cb
                      cd:u32[1000000,1,2] = slice[
                        limit_indices=(1000000, 1, 2)
                        start_indices=(0, 0, 0)
                        strides=(1, 1, 1)
                      ] cc
                      ce:u32[1000000,2] = squeeze[dimensions=(1,)] cd
                      cf:u32[1000000,1,2] = slice[
                        limit_indices=(1000000, 2, 2)
                        start_indices=(0, 1, 0)
                        strides=(1, 1, 1)
                      ] cc
                      cg:u32[1000000,2] = squeeze[dimensions=(1,)] cf
                      ch:key<fry>[1000000] = random_wrap[impl=fry] ce
                      ci:f32[1000000,1] = pjit[
                        name=_normal
                        jaxpr={ lambda ; cj:key<fry>[1000000]. let
                            ck:f32[1000000,1] = pjit[
                              name=_normal_real
                              jaxpr={ lambda ; cl:key<fry>[1000000]. let
                                  cm:f32[1000000,1] = pjit[
                                    name=_uniform
                                    jaxpr={ lambda ; cn:key<fry>[1000000] co:f32[]
                                        cp:f32[]. let
                                        cq:f32[1] = broadcast_in_dim[
                                          broadcast_dimensions=()
                                          shape=(1,)
                                          sharding=None
                                        ] co
                                        cr:f32[1] = broadcast_in_dim[
                                          broadcast_dimensions=()
                                          shape=(1,)
                                          sharding=None
                                        ] cp
                                        cs:u32[1000000,1] = random_bits[
                                          bit_width=32
                                          shape=(1,)
                                        ] cn
                                        ct:u32[1000000,1] = shift_right_logical cs
                                          9
                                        cu:u32[1000000,1] = or ct 1065353216
                                        cv:f32[1000000,1] = bitcast_convert_type[
                                          new_dtype=float32
                                        ] cu
                                        cw:f32[1000000,1] = sub cv 1.0
                                        cx:f32[1] = sub cr cq
                                        cy:f32[1,1] = broadcast_in_dim[
                                          broadcast_dimensions=(np.int64(1),)
                                          shape=(1, 1)
                                          sharding=None
                                        ] cx
                                        cz:f32[1000000,1] = mul cw cy
                                        da:f32[1,1] = broadcast_in_dim[
                                          broadcast_dimensions=(np.int64(1),)
                                          shape=(1, 1)
                                          sharding=None
                                        ] cq
                                        db:f32[1000000,1] = add cz da
                                        dc:f32[1,1] = broadcast_in_dim[
                                          broadcast_dimensions=(np.int64(1),)
                                          shape=(1, 1)
                                          sharding=None
                                        ] cq
                                        dd:f32[1000000,1] = max dc db
                                      in (dd,) }
                                  ] cl -0.9999999403953552 1.0
                                  de:f32[1000000,1] = erf_inv cm
                                  df:f32[1000000,1] = mul 1.4142135381698608 de
                                in (df,) }
                            ] cj
                          in (ck,) }
                      ] ch
                      dg:f32[1,1] = broadcast_in_dim[
                        broadcast_dimensions=(np.int64(1),)
                        shape=(1, 1)
                        sharding=None
                      ] bp
                      dh:f32[1000000,1] = mul ci dg
                      di:f32[1000000,1] = add bv dh
                      dj:f32[1000000,1] = split[axis=1 sizes=(np.int64(1),)] di
                      dk:f32[1000000] = reshape[
                        dimensions=None
                        new_sizes=(1000000,)
                        sharding=None
                      ] dj
                      dl:f32[1000000] dm:f32[1000000] dn:bool[] = pjit[
                        name=_log_prob
                        jaxpr={ lambda ; do:f32[1000000]. let
                            dp:f32[] = sqrt 6.283185307179586
                            dq:f32[] = mul dp 1.0
                            dr:f32[] = log dq
                            ds:f32[1000000] = sub do 0.0
                            dt:f32[1000000] = div ds 1.0
                            du:f32[1000000] = integer_pow[y=2] dt
                            dv:f32[1000000] = mul -0.5 du
                            dw:f32[] = convert_element_type[
                              new_dtype=float32
                              weak_type=False
                            ] dr
                            dx:f32[1000000] = sub dv dw
                            dy:bool[1000000] = eq do do
                            dz:bool[1000000] = ne do inf
                            ea:bool[1000000] = and dy dz
                            eb:bool[1000000] = ne do -inf
                            ec:bool[1000000] = and ea eb
                            ed:f32[1000000] = pjit[
                              name=_where
                              jaxpr={ lambda ; ee:bool[1000000] ef:f32[1000000] eg:f32[]. let
                                  eh:f32[] = convert_element_type[
                                    new_dtype=float32
                                    weak_type=False
                                  ] eg
                                  ei:f32[1000000] = broadcast_in_dim[
                                    broadcast_dimensions=()
                                    shape=(1000000,)
                                    sharding=None
                                  ] eh
                                  ej:f32[1000000] = select_n ee ei ef
                                in (ej,) }
                            ] ec dx -inf
                            ek:f32[1000000] = reduce_sum[axes=()] ed
                            el:f32[1000000] = add 0.0 ek
                            em:bool[1000000] = eq do do
                            en:bool[1000000] = ne do inf
                            eo:bool[1000000] = and em en
                            ep:bool[1000000] = ne do -inf
                            _:bool[1000000] = and eo ep
                            eq:f32[] = sqrt 6.283185307179586
                            er:f32[] = mul eq 0.1
                            es:f32[] = log er
                            et:f32[1000000] = sub 4.0 do
                            eu:f32[1000000] = div et 0.10000000149011612
                            ev:f32[1000000] = integer_pow[y=2] eu
                            ew:f32[1000000] = mul -0.5 ev
                            ex:f32[] = convert_element_type[
                              new_dtype=float32
                              weak_type=False
                            ] es
                            ey:f32[1000000] = sub ew ex
                            ez:f32[1000000] = pjit[
                              name=_where
                              jaxpr={ lambda ; fa:bool[] fb:f32[1000000] fc:f32[]. let
                                  fd:f32[] = convert_element_type[
                                    new_dtype=float32
                                    weak_type=False
                                  ] fc
                                  fe:f32[1000000] = broadcast_in_dim[
                                    broadcast_dimensions=()
                                    shape=(1000000,)
                                    sharding=None
                                  ] fd
                                  ff:f32[1000000] = select_n fa fe fb
                                in (ff,) }
                            ] True ey -inf
                            fg:f32[1000000] = reduce_sum[axes=()] ez
                            fh:f32[1000000] = add 0.0 fg
                          in (el, fh, True) }
                      ] dk
                      fi:f32[1000000] = convert_element_type[
                        new_dtype=float32
                        weak_type=False
                      ] bs
                      fj:f32[1000000] = mul fi dm
                      fk:f32[1000000] = add dl fj
                      fl:f32[1000000] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(1000000,)
                        sharding=None
                      ] -inf
                      fm:f32[1000000] = select_n dn fl fk
                      fn:bool[1000000,1] = eq di di
                      fo:bool[1000000,1] = ne di inf
                      fp:bool[1000000,1] = and fn fo
                      fq:bool[1000000,1] = ne di -inf
                      _:bool[1000000,1] = and fp fq
                      fr:f32[] = sqrt 6.283185307179586
                      fs:f32[] = convert_element_type[
                        new_dtype=float32
                        weak_type=False
                      ] fr
                      ft:f32[1] = mul fs bq
                      fu:f32[1] = log ft
                      fv:f32[1000000,1] = sub bv di
                      fw:f32[1,1] = broadcast_in_dim[
                        broadcast_dimensions=(np.int64(1),)
                        shape=(1, 1)
                        sharding=None
                      ] bq
                      fx:f32[1000000,1] = div fv fw
                      fy:f32[1000000,1] = integer_pow[y=2] fx
                      fz:f32[1000000,1] = mul -0.5 fy
                      ga:f32[1,1] = broadcast_in_dim[
                        broadcast_dimensions=(np.int64(1),)
                        shape=(1, 1)
                        sharding=None
                      ] fu
                      gb:f32[1000000,1] = sub fz ga
                      gc:bool[1000000,1] = eq bv bv
                      gd:bool[1000000,1] = ne bv inf
                      ge:bool[1000000,1] = and gc gd
                      gf:bool[1000000,1] = ne bv -inf
                      gg:bool[1000000,1] = and ge gf
                      gh:f32[1000000,1] = pjit[name=_where jaxpr=_where] gg gb -inf
                      gi:f32[1000000] = reduce_sum[axes=(np.int64(1),)] gh
                      gj:f32[] = sqrt 6.283185307179586
                      gk:f32[] = convert_element_type[
                        new_dtype=float32
                        weak_type=False
                      ] gj
                      gl:f32[1] = mul gk bp
                      gm:f32[1] = log gl
                      gn:f32[1000000,1] = sub di bv
                      go:f32[1,1] = broadcast_in_dim[
                        broadcast_dimensions=(np.int64(1),)
                        shape=(1, 1)
                        sharding=None
                      ] bp
                      gp:f32[1000000,1] = div gn go
                      gq:f32[1000000,1] = integer_pow[y=2] gp
                      gr:f32[1000000,1] = mul -0.5 gq
                      gs:f32[1,1] = broadcast_in_dim[
                        broadcast_dimensions=(np.int64(1),)
                        shape=(1, 1)
                        sharding=None
                      ] gm
                      gt:f32[1000000,1] = sub gr gs
                      gu:bool[1000000,1] = eq di di
                      gv:bool[1000000,1] = ne di inf
                      gw:bool[1000000,1] = and gu gv
                      gx:bool[1000000,1] = ne di -inf
                      gy:bool[1000000,1] = and gw gx
                      gz:f32[1000000,1] = pjit[name=_where jaxpr=_where] gy gt -inf
                      ha:f32[1000000] = reduce_sum[axes=(np.int64(1),)] gz
                      hb:f32[1000000] = sub gi ha
                      hc:f32[1000000] = convert_element_type[
                        new_dtype=float32
                        weak_type=False
                      ] bu
                      hd:f32[1000000] = sub fm hc
                      he:key<fry>[1000000] = random_wrap[impl=fry] cg
                      hf:f32[1000000] = pjit[
                        name=_uniform
                        jaxpr={ lambda ; hg:key<fry>[1000000] hh:f32[] hi:f32[]. let
                            hj:f32[] = convert_element_type[
                              new_dtype=float32
                              weak_type=False
                            ] hh
                            hk:f32[] = convert_element_type[
                              new_dtype=float32
                              weak_type=False
                            ] hi
                            hl:u32[1000000] = random_bits[bit_width=32 shape=()] hg
                            hm:u32[1000000] = shift_right_logical hl 9
                            hn:u32[1000000] = or hm 1065353216
                            ho:f32[1000000] = bitcast_convert_type[
                              new_dtype=float32
                            ] hn
                            hp:f32[1000000] = sub ho 1.0
                            hq:f32[] = sub hk hj
                            hr:f32[1000000] = mul hp hq
                            hs:f32[1000000] = add hr hj
                            ht:f32[1000000] = max hj hs
                          in (ht,) }
                      ] he 0.0 1.0
                      hu:f32[1000000] = log hf
                      hv:f32[1000000] = add hd hb
                      hw:bool[1000000] = lt hu hv
                      hx:i32[1000000] = convert_element_type[
                        new_dtype=int32
                        weak_type=False
                      ] hw
                      hy:bool[1000000] = eq hx 0
                      hz:f32[1000000] = stop_gradient dk
                      _:f32[1000000] = select_n hy hz dk
                      ia:f32[1000000] = stop_gradient fm
                      _:f32[1000000] = select_n hy ia fm
                      ib:f32[1000000] = stop_gradient bt
                      ic:f32[1000000] = select_n hy ib bt
                      id:f32[1000000] = stop_gradient bu
                      ie:f32[1000000] = select_n hy id bu
                      if:bool[1000000] = eq hx 1
                      ig:f32[1000000] = stop_gradient dk
                      ih:f32[1000000] = select_n if ig dk
                      ii:f32[1000000] = stop_gradient fm
                      ij:f32[1000000] = select_n if ii fm
                      ik:f32[1000000] = stop_gradient bt
                      _:f32[1000000] = select_n if ik bt
                      il:f32[1000000] = stop_gradient bu
                      _:f32[1000000] = select_n if il bu
                      im:f32[1000000] = select_n hx ic ih
                      in:f32[1000000] = select_n hx ie ij
                    in (im, in) }
                ] bm ba bb bc
                io:i32[1000000] = add z 1
              in (io, bn, bo) }
          ] r s t u v
        in (w, s, x, y) }
      length=1000
      linear=(False, False, False, False, False)
      num_carry=4
      num_consts=0
      reverse=False
      unroll=1
    ] j k l m i
  in (n, o, p, q) }